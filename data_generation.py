import random
from PIL import Image, ImageDraw 
import numpy as np
from matplotlib import pyplot as plt


def cross_on_circle(r,random_size):

    """
    Returns points on a circle with radius r where the lines of a cross start.
    Random size enables some randomness in size and location of cross
    """

    scale = 1
    shift = 1
    if random_size:
        scale = random.uniform(0.5,1)
        shift = random.uniform(0.9,1.1)


    p = lambda r,theta : (scale*r*np.cos(theta) + r*shift,0.8*r*np.sin(theta) + r*shift)

    theta_1 = random.uniform(0,np.pi/2 - np.pi/8)
    theta_2 = random.uniform(np.pi/2 + np.pi/8,np.pi)
    points = (p(r,theta_1),p(r,theta_1 + np.pi),p(r,theta_2),p(r,theta_2 + np.pi))
    return points

def polygon_on_circle(r,n_sides,random_size,regular = True):

    """
    Returns points on a circle with radius r where the lines of a polygon.
    Random size enables some randomness in size and location of polygon.
    """

    scale = 1
    shift = 1
    if random_size:
        scale = random.uniform(0.5,1)
        shift = random.uniform(1,1.2)

    p = lambda r,theta : (scale*r*np.cos(theta) + r*shift,0.8*r*np.sin(theta) + r*shift)

    theta_1 = random.uniform(0,np.pi/2)
    theta = 2*np.pi/n_sides
    
    if regular:
        points = [p(r,theta_1 + theta*i) for i in range(n_sides + 1)]
    else:
        points = [p(r,theta_1)]*(n_sides + 1)
        for i in range(n_sides-1):
            start = theta_1 + np.pi/(n_sides*8)
            end = theta_1 + np.pi/(n_sides*4) + theta
            theta_2 = random.uniform(start,end)
            points[i+1] = p(r,theta_2)
            theta_1 = theta_2
    return points

def cross_array(size,width,random_size = False):

    """
    Returns image array with cross. Generated by PIL.
    Input is size = n of image (n x n), width of lines and bool for random size
    """

    reduction_scale = 5
    padding = size // reduction_scale
    reduced_size = (size // reduction_scale) * (reduction_scale-1)

    cross = cross_on_circle(reduced_size//2,random_size)
    im = Image.new("F", (reduced_size, reduced_size))
    dr = ImageDraw.Draw(im)
    dr.line(cross[0:2], fill="white", width=width)
    dr.line(cross[2:4], fill="white", width=width)

    im_array = np.zeros((size,size))
    im_array[padding//2:size-padding//2,padding//2:size-padding//2] = np.array(im)

    return im_array/255

def polygon_array(size,width,n_sides,random_size = False,regular = True):

    """
    Returns image array with polygon. Generated by PIL.
    Input is size = n of image (n x n), width of lines and bool for random size.
    Regular can enable or disable regularity of angles of polygon
    """

    reduction_scale = 5

    padding = size // reduction_scale
    reduced_size = (size // reduction_scale) * (reduction_scale-1)

    polygon = polygon_on_circle(reduced_size//2,n_sides,random_size,regular)
    im = Image.new("F", (reduced_size, reduced_size))
    dr = ImageDraw.Draw(im)
    dr.line(polygon, fill="white", width=width)

    for point in polygon:
        dr.ellipse((point[0] - width//3, point[1] - width//3, point[0]  + width//3, point[1] + width//3), fill="white")

    im_array = np.zeros((size,size))
    im_array[padding//2:size-padding//2,padding//2:size-padding//2] = np.array(im)

    return im_array//255

def add_noise(image,prob):

    """
    Image which noise should be added. Prob is probability for each pixel to "flip".
    Flips 1 to 0 and 0 to 1 with probability prob.
    """

    n = image.shape[0]
    R = np.random.randint(0,int(1/prob),size = (n,n))
    R[np.where(R > 1)] = 1
    hole = R*image
    dots = 1 - ((1 - image) * R + image)
    return hole + dots

def generate_data(n_samples,size,width,noise_strength = 0,random_size = False,regular_polygons = True,flatten = False):
    
    """
    Constructs crosses with function above, circles, triangles and squares with polygon function.
    Adds noise if instructed.
    Constructs one hot encoding for labels.
    """
    
    
    data = []
    labels = []

    def one_hot(i,n):
        z = np.zeros(n)
        z[i] = 1
        return z

    for i in range(n_samples):

        if width == "random":
            width = random.randint(min([size // 20,3]), min([size // 5, 5]))

        cross = cross_array(size,width,random_size=random_size)
        circle = polygon_array(size,width,n_sides = 40,random_size=random_size)
        triangle = polygon_array(size,width,n_sides = 3,regular = regular_polygons,random_size=random_size)
        square = polygon_array(size,width,n_sides = 4,regular = regular_polygons,random_size=random_size)
        pentagon = polygon_array(size,width,n_sides = 5,regular = regular_polygons,random_size=random_size)

        if noise_strength: 
            cross = add_noise(cross,noise_strength)
            circle = add_noise(circle,noise_strength)
            triangle = add_noise(triangle,noise_strength)
            square = add_noise(square,noise_strength)
            pentagon = add_noise(pentagon,noise_strength)

        if flatten:
            cross = cross.flatten()
            circle = circle.flatten()
            triangle = triangle.flatten()
            square = square.flatten()
            pentagon = pentagon.flatten()

        data += [cross,circle,triangle,square,pentagon]
        labels += [one_hot(i,5) for i in range(5)]

    return np.array(data).T,np.array(labels).T


def generate_1D_test(length = 40,n_samples = 100,hole_range = [5,30]):

    R = np.ones((n_samples,length))
    hole_sizes = []
    for i in range(n_samples):
        hole_size = np.random.randint(hole_range[0],hole_range[1])
        start_index = np.random.randint(2,length-hole_size-1)
        R[i,start_index:start_index + hole_size] = 0
        R[i,start_index - 1] = 1
        R[i,start_index + hole_size] = 1
        hole_sizes += [hole_size] 

    return R.T,np.array(hole_sizes)[np.newaxis]
